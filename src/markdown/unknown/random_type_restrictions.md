## Случайности не случайны

В мире C++ есть довольно странные ограничения, одно из них связано с генерацией случайных чисел.
Рассмотрим такую задачу: требуется сгенерировать случайный байт со значениями от 1 до 6 (представим, что бросаем кубик).
К сожалению, такой абсоллютно логичный вариант содержит в себе UB:
```cpp
#include <cstddef>
#include <random>
#include <iostream>

int main() {
    std::mt19937 gen;
    std::uniform_int_distribution<uint8_t> distr(1, 6);

    for (int i = 0; i < 10; ++i) {
        const uint8_t dice = distr(gen);
        std::cout << static_cast<int>(dice) << " ";
    }
}

```

Что может быть не так? Оказывается, стандарт разрешает использовать только определенные типы для специализации шаблонов генераторов псведослучайных чисел и их распределений.
[Следуя](https://eel.is/c++draft/rand.req.genl#1.4) [букве](https://eel.is/c++draft/rand.req.genl#1.5) [стандарта](https://eel.is/c++draft/rand.req.genl#1.6) для все шаблоны в заголовке `<random>` подчиняются следующим правилам:
- Если есть параметр с именем `RealType`, то его возможно специализировать только типами `float`, `double`, `long double`.
- Если есть параметр с именем `UIntType`, то его возможно специализировать только типами `unsigned short`, `unsigned int`, `unsigned long`, `unsigned long long`.
- Если есть параметр с именем `IntType`, то его можно специализировать типами из `UIntType` и их знаковыми альтернативами.

Все остальное - UB. Ни разные вариаенты `char`, ни fixed-wide числа с плавающей запятой, такие как `std::float16_t` не могут быть использованы.
Странность этого случая в том, что с технической точки зрения UB можно было бы избежать простой проверкой типов, используя `static_assert` или любые другие способы.
